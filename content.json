{"meta":{"title":"佳的个人博客","subtitle":null,"description":null,"author":"佳","url":"https://LiuPjia.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-07-08T15:20:12.000Z","updated":"2019-07-08T15:45:00.362Z","comments":true,"path":"categories/index.html","permalink":"https://LiuPjia.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-08T15:23:59.000Z","updated":"2019-07-08T15:44:43.884Z","comments":true,"path":"tags/index.html","permalink":"https://LiuPjia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hello","slug":"hello","date":"2019-07-09T05:49:16.000Z","updated":"2019-07-09T05:50:02.019Z","comments":true,"path":"2019/07/09/hello/","link":"","permalink":"https://LiuPjia.github.io/2019/07/09/hello/","excerpt":"","text":"","categories":[{"name":"测试","slug":"测试","permalink":"https://LiuPjia.github.io/categories/测试/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://LiuPjia.github.io/tags/hello/"}]},{"title":"二分法介绍","slug":"二分法介绍","date":"2019-07-08T14:49:38.000Z","updated":"2019-07-09T14:52:43.954Z","comments":true,"path":"2019/07/08/二分法介绍/","link":"","permalink":"https://LiuPjia.github.io/2019/07/08/二分法介绍/","excerpt":"二分法的一些介绍二分法最简单的用法是在一个有序序列中查找一个数x，每次选择中间数进行猜测，不断的缩小其范围。这是最基本的办法，但是二分法的用处不止如此，比如我们直到一个序列的规律之后，我们可以利用某些条件,来逼近我们想要的结果。下面是代码：","text":"二分法的一些介绍二分法最简单的用法是在一个有序序列中查找一个数x，每次选择中间数进行猜测，不断的缩小其范围。这是最基本的办法，但是二分法的用处不止如此，比如我们直到一个序列的规律之后，我们可以利用某些条件,来逼近我们想要的结果。下面是代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * 条件：在一个递增序列中查询一个数 */ int binarySearch(int a[], int left, int right, int x) &#123; int mid; while(left &lt;= right) &#123;//当等于的时候也要判断一下，a[mid] == x mid = left + (right + left) / 2;//避免yi'ch4u if(a[mid] == x) &#123; return mid; &#125;else if(a[mid] &gt; x) &#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return -1;&#125;/** * 求出序列中第一个大于等于X的位置，以及第一个大于x的位置，这个位置是假设存在的应该的值*///求出序列中第一个大于等于X的位置int lower_bound(int a[], int left, int right, int x) &#123; //用left与right不断的逼近，最小的大于x的点 int mid; while(left &lt; right) &#123;//等于的时候说明找到了唯一的点 mid = left + (right - left) / 2; if(a[mid] &gt;= x) &#123; right = mid; &#125;else&#123; left = mid + 1; &#125; &#125; return left;&#125;//求出序列第一个大于x元素的位置int upper_bound(int a[], int left, int right, int x) &#123; int mid; while(left &lt; right) &#123; mid = left + (right - left) / 2; if(a[mid] &gt; x) &#123; right = mid; &#125;else&#123; left = mid + 1; &#125; &#125; return left;&#125;/** * 总结：以上的代码说明了同一个问题，在有序的序列中寻找第一个满足条件的位置，基本思想是找到满足条件的位置， * 然后不断缩小位置，直到找到了唯一解：left = right， 而如果只查询是否存在用第一种解法。 */","categories":[{"name":"算法","slug":"算法","permalink":"https://LiuPjia.github.io/categories/算法/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://LiuPjia.github.io/tags/二分/"}]}]}